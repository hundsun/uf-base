<?xml version="1.0" encoding="UTF-8"?>
<logic:LogicFunction xmlns:logic="http://www.hundsun.com/ares/studio/cres/logic/1.0.0" interfaceFlag="" name="LF_DEMOUSER_BUSI_EXP_NOT_EXIT" chineseName="LF_演示用户管理_结果集X标志返回" description="业务异常不退出" objectId="1100001" pseudoCode="/********************************************************************&#xA;**&#xA;** [事务型函数和非事务型函数]&#xA;**   功能：对跨数据库用户操作进行事务型一致性保护&#xA;**   范围：逻辑函数&#xA;**   注意：&#xA;**&#xA;********************************************************************/&#xA;&#xA;// 重做业务，重置冲销流水号，根据送入的冲销流水号来补做业务&#xA;if (@redo_flag == '1')&#xA;{&#xA;hs_strcpy(@cancel_serialno, @cancel_serialno_t);&#xA;}&#xA;else&#xA;{&#xA;[AS_演示用户管理_证券冻结解冻确认]&#xA;// 1-1) 返回超时错误，不能确定是否成功，冲正也会存在并发问题，不妥，因此直接告诉前台检查业务情况&#xA;//      此处还是增加业务处理异常记录为宜，主要是担心stock表被锁的情况，一旦解锁就会单边，因此要记录异常信息；其他诸如原子AS异常退出的情况下，此时记录异常信息也会超时&#xA;if (iReturnCode == ERR_SUBSERVICE_CALL_TIMEOUT)&#xA;{&#xA;@error_no_t = @error_no;&#xA;sprintf(@error_info_t, &quot;存管系统中业务操作超时；请联系总部运维人员检查业务操作是否成功！&quot;);&#xA;//由于演示用户调用失败，需要进行异常业务业务记录，以保证单边业务能够重新处理&#xA;//演示模块没有&#xA;&lt;M>[AS_演示用户管理_业务处理异常记录][init_date=@sys_init_date]&#xA;iReturnCode = @error_no_t;&#xA;@error_no = @error_no_t;&#xA;hs_strcpy(@error_info,@error_info_t);&#xA;goto svr_end;&#xA;}&#xA;// 1-2) 返回业务错误，肯定不成功，直接告诉前台具体错误&#xA;else if (iReturnCode != 0 &amp;&amp; iReturnCode != ERR_SYSWARNING)&#xA;{&#xA;goto svr_end;&#xA;}&#xA;}&#xA;&#xA;[AS_演示账户管理_股份交易信息表字段更改][init_date=@secu_init_date,real_action='0',occur_amount=@occur_amount_real,remark=@op_remark,&#xA;current_amount_secu=@current_amount,post_amount=@enable_amount]&#xA;if (iReturnCode == ERR_SUBSERVICE_CALL_TIMEOUT)&#xA;{&#xA;if (@redo_flag == '1')&#xA;{&#xA;@error_no_t = @error_no;&#xA;sprintf(@error_info_t, &quot;补做订单系统业务，操作超时；请联系总部运维人员检查业务操作是否成功！&quot;);&#xA;}&#xA;else&#xA;{&#xA;@error_no_t = @error_no;&#xA;sprintf(@error_info_t, &quot;存管系统中业务操作成功，订单系统中业务操作超时；请联系总部运维人员检查业务操作是否成功！&quot;);&#xA;@sysnode_id = 0;&#xA;&lt;M>[AS_演示用户管理_业务处理异常记录][init_date=@sys_init_date]&#xA;}&#xA;}&#xA;// 2-2) 返回业务错误，肯定不成功，此时可以冲正，但是冲正也会引发超时或其它并发错误，因此&#xA;//      对于重做类业务，直接报错返回给前台，后续等异常恢复后再做，总能成功&#xA;//      对于正常类业务，先记录业务处理异常（记录过程发生错误或超时，概率小不考虑特殊处理），再报错返回&#xA;else if (iReturnCode != 0)&#xA;{&#xA;if (@redo_flag == '1')&#xA;{&#xA;@error_no_t = @error_no;&#xA;sprintf(@error_info_t, &quot;补做订单系统业务，操作报错: %s；请联系总部运维人员检查业务操作是否成功！&quot;, @error_info);&#xA;}&#xA;else&#xA;{&#xA;@error_no_t = @error_no;&#xA;sprintf(@error_info_t, &quot;存管系统中业务操作成功，订单系统中业务操作报错: %s；请联系总部运维人员检查业务操作是否成功！&quot;, @error_info);&#xA;@sysnode_id = 0;&#xA;&lt;M>[AS_演示用户管理_业务处理异常记录][init_date=@sys_init_date]&#xA;}&#xA;}&#xA;// 2-3) 处理成功，将secuexceptinfo表内记录状态更新&#xA;else&#xA;{&#xA;//20090615 wangxl add 只有在重做的时候才会有update secuexceptinfo 的可能和必要&#xA;if (@redo_flag == '1')&#xA;{&#xA;@sysnode_id = 0;&#xA;&lt;M>[AS_演示用户管理_业务处理异常记录][deal_status=1]&#xA;}&#xA;}&#xA;&#xA;// 3、存管子系统处理不成功，前面已经报错返回&#xA;//    订单子系统处理，如果是重做业务，那么只有重做成功才记录日志；重做失败不记录日志&#xA;//                 如果是正常业务，那么无论是单边账产生，还是全部成功，一律记录操作日志&#xA;//   这样做的风险在于重做业务后，此业务有两条日志，不过从日志本身的含义而言，这也应该是这样的&#xA;//    对于单边注意将错误信息记录到操作备注中&#xA;if (@redo_flag == '1')&#xA;{&#xA;if (@error_no_t == 0)&#xA;{&#xA;//sprintf(@op_remark,&quot;%s, %s&quot;, @op_remark, &quot;业务补做, &quot;);&#xA;hs_strcat(@op_remark,&quot;, 业务补做,&quot;);&#xA;@sysnode_id = 0;&#xA;[AS_演示用户管理_用户操作日志记录][init_date=@sys_init_date,operator_action=8,trade_account=@stock_account]&#xA;}&#xA;}&#xA;else&#xA;{&#xA;if (@error_no_t != 0)&#xA;{&#xA;sprintf(@op_remark,&quot;%s, %s&quot;, @op_remark, @error_info_t);&#xA;}&#xA;@sysnode_id = 0;&#xA;[AS_演示用户管理_用户操作日志记录][init_date=@sys_init_date,operator_action=8,trade_account=@stock_account]&#xA;}&#xA;&#xA;// 4、如果因为单边出错，则记录日志后再此处将报错信息返回&#xA;if (@error_no_t != 0)&#xA;{&#xA;iReturnCode = @error_no_t;&#xA;@error_no = @error_no_t;&#xA;hs_strcpy(@error_info, @error_info_t);&#xA;goto svr_end;&#xA;}&#xA;">
  <inputParameters id="op_branch_no" flags="D"/>
  <inputParameters id="operator_no" flags="D"/>
  <inputParameters id="user_type" flags="D"/>
  <inputParameters id="op_password" flags="D"/>
  <inputParameters id="op_station" flags="D"/>
  <inputParameters id="op_entrust_way" flags="D"/>
  <inputParameters id="menu_id" flags="D"/>
  <inputParameters id="function_id" flags="D"/>
  <inputParameters id="branch_no" flags="D"/>
  <inputParameters id="action_in" flags=""/>
  <inputParameters id="client_id" flags=""/>
  <inputParameters id="fund_account" flags=""/>
  <inputParameters id="exchange_type" flags=""/>
  <inputParameters id="stock_account" flags=""/>
  <inputParameters id="stock_code" flags=""/>
  <inputParameters id="occur_amount" flags=""/>
  <inputParameters id="valid_date" flags=""/>
  <inputParameters id="join_info" flags=""/>
  <inputParameters id="frozen_reason" flags=""/>
  <inputParameters id="remark" flags=""/>
  <inputParameters id="business_flag" flags=""/>
  <inputParameters id="sys_init_date" flags=""/>
  <inputParameters id="curr_date" flags=""/>
  <inputParameters id="curr_time" flags=""/>
  <inputParameters id="secu_init_date" flags=""/>
  <inputParameters id="sysnode_id_t" flags=""/>
  <inputParameters id="client_group" flags=""/>
  <inputParameters id="room_code" flags=""/>
  <inputParameters id="product_flag" flags=""/>
  <inputParameters id="stock_type" flags=""/>
  <inputParameters id="money_type" flags=""/>
  <inputParameters id="frozen_amount" flags=""/>
  <inputParameters id="unfrozen_amount" flags=""/>
  <inputParameters id="occur_amount_real" flags=""/>
  <inputParameters id="redo_flag" flags=""/>
  <inputParameters id="cancel_serialno_t" flags=""/>
  <outputParameters id="op_remark" flags="IO"/>
  <outputParameters id="cancel_serialno" flags=""/>
  <outputParameters id="serial_no" flags=""/>
  <outputParameters id="stkrevertjour_no" flags=""/>
  <outputParameters id="current_amount" flags=""/>
  <outputParameters id="enable_amount" flags=""/>
</logic:LogicFunction>
